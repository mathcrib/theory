<h1>Векторы. Введение</h1>  

<h2>Основные понятия</h2>  

Машинное обучение от простейшей линейной регрессии до сверточных нейронных сетей строится на линейной алгебре, работе с матрицами и векторами. Изображение или текст можно перевести в вектор и произвести над ним различные преобразования, например, научить модель распознавать, кто изображен на картинке или какой окрас имеет текст комментария.
В нейронных сетях матрицами устанавливаются параметры, необходимые для преобразования слоев с информацией в процессе вычисления.

В данной статье мы рассмотрим теорию и практическое применение векторов. Код написан на языке python с использованием библиотеки numpy. Информация будет полезна всем, кто делает первые шаги в ml и data science.
 

Начнем.

<h3>Скаляр</h3>   

Линейная алгебра строится вокруг работы с массивами данных. **Массив** (*англ. Array*) - особая последовательность элементов, которая состоит из отдельных единиц - вещественных, натуральных или комплексных чисел. Все элементы массива должны принадлежать к одному типу данных.

В учебниках можно встретить термин **скаляр**, который служит для описания структурной единицы, описывающей поле вектора. Скаляры служат координатами точек в пространстве.Изображается скаляр буквой латинского или греческого алфавита. Следующая формула говорит о том, что скаляр S принадлежит множеству вещественных чисел.


<p align="center">
   <img src = https://s3.tproger.ru/uploads/2019/07/image-7.png title='Математическая запись скаляра'>
</p>

*Все необходимые математические символы и определения можно посмотреть [здесь](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2)*

От структурных единиц перейдем к более сложным образованиям.


<h3>Определение вектора</h3> 

**Вектор** - упорядоченная последовательность скаляров. Векторы могут быть любой длины, но всегда одномерны - одна строка в записи. Стуктурами следующих порядков являются матрицы (двухмерные) и тензоры(n-мерные). Информацию о них вы найдете в следующих статьях.

Каждый элемент вектора имеет индекс, представлен цифрой возде каждого элемента на рисунке ниже. 

<p align="center">
  <img src="https://s3.tproger.ru/uploads/2019/07/image-8.png" title='Математическая запись вектора'>
</p>

В начале пути машинного обучения, будьте готовы к тому, что один и тот же термин в разных источниках может быть описан различными словами. 
Например, вектором могут быть - массив, кортеж, последовательность. Вы быстро сможете привыкнуть к такому разбросу слов, однако, на первых этапах может быть некоторая путаница.

В машинном обучении векторы применяются, например, для описания состояния целевой переменой при обучении алгоритма. 
То есть, если мы изучаем 5 студентов и объем их курсового проекта в страницах, то вектор целевого признака будет иметь следующий вид:

y = [200, 325, 185, 220, 483]  

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/VectorAB.svg/300px-VectorAB.svg.png" title='Отображение вектора на плоскости'>
</p>

Рисунок повторяет иллюстрацию из школьного учебника. Учитель говорил нам, что вектор - это направленный отрезок, имеющий начало и конец. 
Перед нами вектор  <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> с началом в точке A и концом в точке B. Его можно так же представить как вектор <img src="https://latex.codecogs.com/gif.latex?\vec{AB}">. Сразу напомним, что вектора, проложенные между двумя точками но в разных направлениях не равны друг другу, то есть:  <img src="https://latex.codecogs.com/gif.latex?\vec{AB}\neq\vec{BA}">. Данное условие будет работать с матрицами и тензорами.  

*Длина вектора* - длина отрезка AB, при написании обозначается, как математический модуль |AB|. 
Существует *нулевой вектор* - это точка на плоскости, <img src="https://latex.codecogs.com/gif.latex?\vec{0}=0">. 

*Забегая немного вперед, приведем пример из работы с текстом, просто для иллюстрации, пока не забивайте им голову.*

После преобразования слов в вектора, можно выявить закономерность, что, условно, расстояние (вектор) между слова "king" и "queen" равно расстоянию (вектору) между словами "man" и "woman" и между словами "uncle" и "aunt". Это свойство помогает математической модели понять, как соотносятся слова в этих парах. И, например, что во множесвенном числе данных слов будут действовать так же вектора одной длины.

<p align="center">
   <img src = https://hsto.org/getpro/habr/post_images/9dd/1dc/5ea/9dd1dc5eabaa9a645a12a0a272dd5769.png title='Векторы в mlp'>
</p>

В аналитической геометрии вы можете встретиться с понятием **свободный вектор**. Такой вектор не привязан к определенной точке, а просто обозначет направленный отрезок определенной длины. Такой вектор можно приложить к любой точке в пространстве. Речь в статье будет идти именно про такие векторы. Про *несвободные векторы* можно прочитать [здесь](http://mathprofi.ru/teoriya_polya.html).

<h2>Операции с векторами</h2>

Мы вспомнили, что такое векторы и для чего они нужны. Перейдем к работе с векторами. В данном разделе мы соединим теорию и практикический код на python, чтобы вся информация была у вас в одном месте.

Первое, что нам необходимо сделать, импортировать numpy - базовую библиотеку для задач по линейной алгебре. 

```python
import numpy as np
```
<h3>Сложение векторов</h3>

Наглядно, то есть на рисунке, векторы складываются по правилу треугольника или параллелограмма, в случае двух векторов, или многоугольника, в случае сложения нескольких векторов. Разберем на конкретном примере.

<p align="center">
   <img src= https://i.ibb.co/18mgsjM/vec-vec-addition.jpg title='Правило треугольника и параллелограмма'>
</p>

Правила треугольника и параллелограмма похожи. 
На левом изображении представлено сложение треугольником.  
Вектор <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> подставляется в конец вектора <img src="https://latex.codecogs.com/gif.latex?\vec{a}">, благодаря тому, что векторы свободны, и мы можем переставлять их в пространстве не изменяя направления и длины. Проводим из начала ветора <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> в конец <img src="https://latex.codecogs.com/gif.latex?\vec{b}">  новый вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, длина которого равна сумме исходных векторов.  

В методе параллелограмма два вектора выходят из одной точки, образуя угол. После чего из концов векторов откладываются парные вектора - из <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> выходит <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> и наоборот. Получается параллелограм. Из начальной точки проводится вектор в противоположный угол новой фигуры, получается результирующий вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">. 

<p align="center">
   <img src="https://i.ibb.co/dWjZ6pV/vec-vec-addition-multi.jpg" title='Правило многоугольника'>
</p>

При графическом сложении нескольких векторов каждый следующий вектор окладывается из конца предыдущего, <img src="https://latex.codecogs.com/gif.latex?\vec{a}_{2}\dots\vec{a}_6">. Далее из начала первого вектора откладывается вектор в конец последнего, <img src="https://latex.codecogs.com/gif.latex?\vec{c}">. Новый вектор является результирующим.  

Отметим два закона сложения векторов: коммутативный и ассоциативный.  
*Коммунитативный закон*: векторы при сложении можно переставлять местами без изменения результата. Матрицы, в отличие от векторов, не поддерживают этот закон.  

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=\vec{b}+\vec{a}" >
</p>

*Ассоциативный закон* выглядит следующим образом:  

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?(\vec{a}+\vec{b})+\vec{c}=\vec{a}+(\vec{b}+\vec{c})" >
</p>

Матрицы можно умножать друг на друга по этому же свойству, но об этом в другой статье.

С изображением и основными законами все понятно, перейдем к числам. Возьмем два вектора <img src="https://latex.codecogs.com/gif.latex?\vec{A}"> [1,-3] и <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> [4,2]    

В данном случае можно представить эти цифры, как координаты [x,y] концов векторов, когда она оба выходят из точки пересечения координатных осей.

<p align="center">
   <img src="https://i.ibb.co/wJcLPQd/vec-vec-addition-jup.jpg" title='Сложение векторов'  height=300>
</p>

При сложении векторов необходимо сложить отдельно все первые координаты точек, затем вторые координаты точек, и так далее, если векторы не ограничиваются только двумя точками, как в примере из начала статьи с пятью студентами и их курсовыми работы.

Общая формула сложения векторов выглядит так:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=(a_{1}+b_{1},a_{2}+b_{2},a_{3}+b_{3})" >
</p>

В нашем случае получим следующий результат:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=(1+2,\,-3+2)=(5,\,-1)">
</p>

Отдадим numpy всю грязную работу и посмотрим, что получится.   

```python
vector_a = np.array([1, -3])
vector_b = np.array([4, 2])

print(sum_of_vectors = vector_a + vector_b)
```
array([ 5, -1])


<h3>Вычитание векторов</h3>

Вычитать векторы так же просто, как и складывать. Графически это выглядит так:

<p align='center'>
   <img src="https://i.ibb.co/zS2nJVq/vec-vec-subtract.jpg" title='Вычитание векторов' height=300>
</p>

На словах звучит чуть сложнее: 

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{b}-\vec{a}=\vec{c}\;\;\;\vec{a}=\vec{c}+\vec{b}">
</p>

При вычитании из вектора <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> из вектора <img src="https://latex.codecogs.com/gif.latex?\vec{a}">, необходимо найти  вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, который при сложении с вектором <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> даст в сумме <img src="https://latex.codecogs.com/gif.latex?\vec{a}">.  

И наоборот, для вычитания <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> из <img src="https://latex.codecogs.com/gif.latex?\vec{b}">, найдем вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, который при сложении с <img src="https://latex.codecogs.com/gif.latex?\vec{a}">, даст в сумме <img src="https://latex.codecogs.com/gif.latex?\vec{b}">.  

Общая формула вычитания векторов похожа по смыслу на сложение

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}-\vec{b}=(a_{1}-b_{1},a_{2}-b_{2},a_{3}-b_{3})" >
</p>

В numpy вычесть вектора так же просто

```python
>>> vector_a = np.array([1, -3])
>>> vector_b = np.array([4, 2])
>>> print(diff_of_vectors_1 = vector_a + vector_b)
>>> print(diff_of_vectors_2 = vector_b + vector_a)
```
array([-3, -5])  
array([3, 5])


<h3>Умножение вектора на число</h3> 

При умножении вектора на число каждый скаляр вектора умножается на это число. В результате получается вектор исходной длины.

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}*{b}=\vec{c}=(a_{1}*b,\;a_{2}*b,\;a_{3}*b)" >
</p>

Рассмотрим примеры, когда вектор <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> ненулевой и число b не равно нулю. Потому что в описанных случаях при умножении мы будем получать нулевой вектор.

При умножении вектора на число всегда получается вектор, параллельный исходному: <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> || <img src="https://latex.codecogs.com/gif.latex?\vec{c}">.   
Если число b положительное, то  <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> ↑↑ <img src="https://latex.codecogs.com/gif.latex?\vec{c}">. Такие векторы направлены в одну сторону и называются сонаправленными.  
Если число b отрицательное, то векторы направлены в разные стороны <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> ↑↓ <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, и такие векторы называются противоположно направленными.  

В numpy умножить вектор на число можно с помощью следующих команд :

```numpy.dot()```,  
простого значка умножения

Произведение с использованием dot() можно записать в двух вариантах:
1. numpy.dot(*вектор*, *число*);  
2. *вектор*.dot(*число*)

```python
vector_a = np.array([5,4,8,10,-3])
b = 4

vector_c = vector_a.dot(b)
vector_d = vector_a * b

print(vector_c)
print(vector_d)
```

[ 20  16  32  40 -12]  
[ 20  16  32  40 -12]
 

<h3>Массивы, списки и немного кода</h3> 

Вопрос - а зачем нам вообще изучать векторы для работы с данными. Ведь можно просто передавать в python списки. Пусть машина работает с ними. Однако, numpy обрабатывает векторамы (arrays), гораздо быстрее, чем голый python списки. Разберем пример.  

Создадим массив со случайными целыми числами длиной 10 млн скаляров. Чувствуете, работем с Big Data!

```python
vec_a = np.random.randint(100, size=10000000)
```

*Операция ```np.random.randint()``` создает массив из случайных целых чисел. Диапазон подбора чисел лежит в границах от 0 до заданного числа, в нашем случае 100. Длина масива задается параметром ```size=...```. Полная информация по этой функции и другие способы создания массивов находятся в официальной ![доке numpy](https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html). Добавьте в закладки и изучите.*

Переведем масив в список (list). Нам поможет функция ```tolist()```.  

```python
list_a = vec_a.tolist()
```
Проверим, что мы все сделали правильно. Выведем первые 5 объектов вектора и списка.  

```python
print(vec_a[:5])
print(list_a[:5])
```
[85 56 17 20 66]  
[85, 56, 17, 20, 66]  

Все идет по плану. Умножим список на число и вектор на число. Сравним время выполнения операций. Начнем со списка.  
Мы не можем просто написать ```list_a * 4```, так как в данном случае просто последовательно соединим четыре раза list_a. Получим новым список длиной 40 млн скаляров.  

```python
list_c = list_a * 4

print(len(list_c)) 
```

40000000

Для того, чтобы корректно каждый элемент списка на число, обратимся к генераторам списков или "списку понимания" (list comprehensions). 

Время выполнения функции (в данном случае в ячейке Jupyter notebook) выведно на экран с помощью команды ```%%time``` модуля IPython, ![ссылку прикладываю](https://ipython.readthedocs.io/en/stable/interactive/magics.html). 
"Магические" и другие полезные функции IPython и Jupyter описаны ![в этой стате на Хабре](https://habr.com/ru/company/wunderfund/blog/316826/).
Если вы не знакомы со вложенными циклами - вам ![сюда](https://webdevblog.ru/kogda-ispolzovat-list-comprehension-v-python/) или ![сюда](https://python-scripts.com/for-in-one-line).

```python
%%time
list_c = ([list_a[i]*4 for i in range(len(list_a))])
```
Wall time: 2.21 s

Операция умножения списка длилась более двух секунд. "Как быстро!", скажете вы и, возможно, будете правы. Взглянем на работу numpy и векторов.  

```python
%%time
vec_c = vec_a*4 

### можно написать так - 
### vec_c = vec_a.dot(4)
### или так - 
### vec_c = np.dot(vec_a, 4)
```  
Wall time: 35.2 ms

Операция потребовала 35 миллисекунд. Сравним это с 2210 миллисекундами, которые потребовались для работы над списком.

```python
2210 / 35.2
```  

62.78409090909091

Numpy обработал массив в 63 раза быстрее! Что вы скажете на этот раз?. В машинном обучении при работе с террабайтными массивами данных экономия времени заметно ускоряет вычисления. 
Переходим к самому интресному - умножению векторов друг на друга.


<h3>Скалярное произведение векторов</h3>   

Существует три варианта умножения веторов: скалярное, ![векторное](http://mathprofi.ru/vektornoe_proizvedenie_vektorov_smeshannoe_proizvedenie.html#spv) и ![смешанное](http://mathprofi.ru/vektornoe_proizvedenie_vektorov_smeshannoe_proizvedenie.html#spv). В рамках машинного обучения чаще всего вы будете пользоваться скалярным произведением. Но обязательно прочитайте про два оставшихся метода по ссылкам выше.  

**Немного теории**  
Для вычисления скалярного произведения векторов необходимо отложить 2 свободных вектора из одной точки и рассчитать угол между ними. Получаем примерно такую картину:

<p align='center'>
   <img src='http://mathprofi.ru/d/skaljarnoe_proizvedenie_vektorov_clip_image008.jpg' title='Векторы и угол между ними'>
</p> 

Из этой иллюстрации выводим определение: скалярным произведением двух векторов <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> и <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> называется **число**, равное произведению длин этих векторов на косинус угла между ними. 
В виде формулы это выглядит так: 

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\;*\;\vec{b}=|\vec{a}|*|\vec{b}|*\cos\angle(\vec{a};\vec{b})">
</p> 

Почему в ответе число, а не массив? Длины векторов <img src="https://latex.codecogs.com/gif.latex?|\vec{a}|"> и <img src="https://latex.codecogs.com/gif.latex?|\vec{b}|">- это числа. Косинус угла между векторами - тоже число. Последовательное умножение трех чисел даст новое число.   
Посмотрим на примере. Возьмем вектор <img src="https://latex.codecogs.com/gif.latex?|\vec{a}|"> длиной 5 и <img src="https://latex.codecogs.com/gif.latex?|\vec{b}|"> длиной 6. Угол между ними, например, 73 градуса. 
Запишем следующее выражение: 

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?ans=|\vec{a}|*|\vec{b}|*\cos\angle(\vec{a};\vec{b})=5*6*\cos(73)">
</p>  

Отправим это выражение в обработку:

```python
ans = 5 * 6 * np.cos(np.radians(73))
print(ans)
```
8.771151141682104

Для перевода градусов в радианы мы использовали функцию ```numpy.radians```. Описание ![здесь](https://numpy.org/doc/stable/reference/generated/numpy.radians.html)

**Еще немного теории**  

Если угол между двумя векторами острый, то есть от 0 до 90 градусов, то произведение векторов будет положительным благодаря положительному косинусу. Если угол между векторами тупой, от 90 до 180 градусов, то скалярное произведение векторов будет отрицательным. Опять же из-за косинуса, который теперь так же отрицательный.   
*Не помните тригонометрию? Загляните ![сюда](https://egemaximum.ru/trigonometricheskiy-krug/)*  

Если векторы строго перпендикулярны друг другу, угол между ними равен 90 градусов. В этом случае косинус угла равен нулю и скалярное произведение также равно нулю. Векторы лежащие друг к другу под прямым углом называются **ортогональными**. В математическом виде это обозначается так:  

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{b}=0\Leftrightarrow\vec{a}\perp\vec{b}">
</p>  

При умножении вектора на себя получается следующее:

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{a}=|\vec{a}|^2">
</p>  

И разберем три закона скалярного произведения векторов.  
1. Коммутативный или переместительный закон: <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{b}=\vec{b}\vec{a}">;    
2. Дистрибутивный или распределительный закон: <img src="https://latex.codecogs.com/gif.latex?(\vec{a}+\vec{b})*\vec{c}=\vec{a}\vec{c}+\vec{a}\vec{c}">;   
3. Ассоциативный или сочетательный закон: <img src="https://latex.codecogs.com/gif.latex?(k*\vec{a})*\vec{b}=k*(\vec{a}\vec{b})"> (константу можно вынести из под скобки).

**Финальная теория**  
Неужели нам придется каждый раз высчитывать углы между векторами и косинусы этих углов? Конечно, нет.  
Если векторы заданы координатами, то в момент скалярного произведения координаты с одинаковыми индексами перемножаются. Все полученные произведения складываются между собой. Рассмотрим в виде формулы:  

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}vec{b}=[a_{1}*b_{1}+a_{2}*b_{2}+a_{3}*b_{3}]">
</p>  

В коде скалярное произведение можно произвести двумя путями:
```python
numpy.dot();
значок @ 
```

Сравним возможные пути решения:  

```python 
vec_a = np.array([4, 5, -1, 3])
vec_b = np.array([-6, 2, 8, 5])

ans_1 = vec_a @ vec_b
ans_2 = np.dot(vec_a, vec_b)

print(ans_1)
print(ans_2)
```

-7  
-7

Результат одинаковый! Используйте любой приём.

<h2>Заключение</h2>  

Мы познакомились с основными свойствами векторов. Посмотрели, как можно складывать, вычитать и перемножать векторы друг на друга и на число. Разобрали основные законы действий над векторами.  
Мы специально не затрагивали некоторые фундаментальные темы, которые требуют отдельного погружению в аналитическую геометрию и высшую математику, чтобы у вас в голове не было математического винегрета.  
В следующей статье мы посмотрим, как векторы применяются на практике в машинном обучении: почему Евклид не любил бы Манхеттен и как превратить слова в вектор.
