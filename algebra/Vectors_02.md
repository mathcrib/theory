<h1>Векторы. Введение</h1>  

В данной статье мы расскажем, что такое векторы и какое практическое применение у них есть. Код написан на языке Python с использованием библиотеки NumPy. Информация будет полезна тем, кто делает первые шаги в Machine Learning и Data Science.

<h2>Основные понятия</h2>  

Машинное обучение строится на линейной алгебре, работе с матрицами и векторами. Изображение или текст можно перевести в вектор и произвести над ним различные преобразования. Например, научить модель распознавать, кто изображен на картинке или какого цвета текст. В нейронных сетях с помощью матриц устанавливают параметры, необходимые для преобразования слоев с информацией в процессе вычисления.

<h3>Определение скаляра и вектора</h3>

<h3>Скаляр</h3>   

Если говорить совсем просто, скаляр – это число. В учебниках можно встретить термин **скаляр**, который означает структурную единицу, описывающую поле вектора. Скаляры служат координатами точек в пространстве. Изображается скаляр буквой латинского или греческого алфавита. Следующая формула говорит о том, что скаляр S принадлежит множеству вещественных чисел.

<p align="center">
   <img src = https://s3.tproger.ru/uploads/2019/07/image-7.png title='Математическая запись скаляра'>
</p>

**Вектор** – упорядоченная последовательность скаляров. Это значит, что каждому скаляру принадлежит свой индекс (номер места), на котором он стоит. Рассмотри рисунок ниже.

<p align="center">
  <img src="https://s3.tproger.ru/uploads/2019/07/image-8.png" title='Математическая запись вектора'>
</p>

Векторы могут быть любой длины, то есть состоять из любого количества скаляров, но всегда одномерны – одна строка в записи. Структурами следующих порядков являются матрицы (двумерные) и тензоры (n-мерные). Информацию о них вы найдете в следующих статьях.

В начале пути машинного обучения будьте готовы к тому, что один и тот же термин в разных источниках может быть описан различными словами.
Например, вектором могут назвать любой из трех списков – массив, кортеж или последовательность.

<p align="center">
  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/VectorAB.svg/300px-VectorAB.svg.png" title='Отображение вектора на плоскости'>
</p>

Данный рисунок повторяет иллюстрацию из школьного учебника. Учитель говорил нам, что вектор – это направленный отрезок, имеющий начало и конец.
Перед нами вектор  <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> с началом в точке A и концом в точке B. Его можно так же представить как вектор <img src="https://latex.codecogs.com/gif.latex?\vec{AB}">. Запомните, что вектора, проложенные между двумя точками, но в разных направлениях, не равны друг другу, то есть:  <img src="https://latex.codecogs.com/gif.latex?\vec{AB}\neq\vec{BA}">. Данное условие будет работать с матрицами и тензорами.

*Длина вектора* – это длина отрезка AB. Она обозначается как математический модуль |AB|.
Существует *нулевой вектор* – это точка на плоскости: <img src="https://latex.codecogs.com/gif.latex?\vec{0}=0">.


*Все необходимые математические символы и определения можно посмотреть [здесь](https://ru.wikipedia.org/wiki/%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2)*

От структурных единиц перейдем к более сложным образованиям.

В машинном обучении векторы применяются, в частности, для описания состояния целевого признака при обучении алгоритма. Целевой признак – это данные, которые являются целью исследования и которые мы хотим предсказать в ходе машинного обучения. 

Например, у нас есть данные о десяти различных характеристиках квартиры: высота потолков, жилая площадь, этаж и т.д. Также мы знаем рыночную стоимость квартир – это и есть целевой признак. Если мы изучаем объявления о продаже пяти квартир, целевой признак (y) будет представлен в виде вектора. Каждый скаляр в этом векторе – это стоимость квартиры в миллионах рублей.

y = [20.0, 3.2, 18.0, 2.2, 48.0]  

В аналитической геометрии вы можете встретиться с понятием **свободный вектор**. Такой вектор не привязан к определенной точке, а просто обозначает направленный отрезок некоторой длины. Его можно приложить к любой точке в пространстве. Речь в статье будет идти именно про такие векторы. Про *несвободные векторы* можно прочитать [здесь](http://mathprofi.ru/teoriya_polya.html).

<h2>Операции с векторами</h2>

Мы вспомнили, что такое векторы и для чего они нужны. Перейдем к работе с векторами. В данном разделе мы соединим теорию и практический код на Python, чтобы вся информация была у вас в одном месте.

Первое, что нам необходимо сделать, – импортировать NumPy. Это базовая библиотека для задач по линейной алгебре.

```python
import numpy as np
```
<h3>Сложение векторов</h3>

Наглядно, то есть на рисунке, векторы складываются по правилу треугольника или параллелограмма в случае с двумя векторами. Или по правилу многоугольника в случае сложения нескольких векторов. Разберем на конкретном примере.

<p align="center">
   <img src= https://i.ibb.co/18mgsjM/vec-vec-addition.jpg title='Правило треугольника и параллелограмма'>
</p>

Правила треугольника и параллелограмма похожи.
На левом изображении представлено сложение треугольником.  
Вектор <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> подставляется в конец вектора <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> благодаря тому, что векторы свободны. И мы можем переставлять их в пространстве, не изменяя направления и длины. Проводим из начала вектора <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> в конец <img src="https://latex.codecogs.com/gif.latex?\vec{b}">  новый вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, длина которого равна сумме исходных векторов.  

В методе параллелограмма два вектора выходят из одной точки, образуя угол. После чего из концов векторов откладываются парные вектора – из <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> выходит <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> и наоборот. Получается параллелограмм. Из начальной точки проводится вектор в противоположный угол новой фигуры, получается результирующий вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">.

<p align="center">
   <img src="https://i.ibb.co/dWjZ6pV/vec-vec-addition-multi.jpg" title='Правило многоугольника'>
</p>

При графическом сложении нескольких векторов каждый следующий вектор откладывается из конца предыдущего, <img src="https://latex.codecogs.com/gif.latex?\vec{a}_{2}\dots\vec{a}_6">. Далее из начала первого вектора откладывается вектор в конец последнего, <img src="https://latex.codecogs.com/gif.latex?\vec{c}"> – он и является результирующим.  

Отметим два закона сложения векторов: коммутативный и ассоциативный.  
*Коммутативный закон*: векторы при сложении можно переставлять местами без изменения результата. Матрицы, в отличие от векторов, не поддерживают этот закон.  

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=\vec{b}+\vec{a}" >
</p>

*Ассоциативный закон* выглядит следующим образом:  

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?(\vec{a}+\vec{b})+\vec{c}=\vec{a}+(\vec{b}+\vec{c})" >
</p>

Матрицы можно умножать друг на друга по этому же свойству, но об этом в другой статье.

С изображением и основными законами все понятно, перейдем к числам. Возьмем два вектора <img src="https://latex.codecogs.com/gif.latex?\vec{A}"> [1,-3] и <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> [4,2]    

В данном случае можно представить эти цифры, как координаты [x,y] концов векторов, когда они оба выходят из точки пересечения координатных осей.

<p align="center">
   <img src="https://i.ibb.co/wJcLPQd/vec-vec-addition-jup.jpg" title='Сложение векторов'  height=300>
</p>

При сложении векторов необходимо сложить отдельно все первые координаты точек, затем вторые координаты точек и так далее (если векторы не ограничиваются только двумя точками, как в примере из начала статьи с ценой квартир).

Общая формула сложения векторов выглядит так:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=(a_{1}+b_{1},a_{2}+b_{2},a_{3}+b_{3})" >
</p>

В нашем случае получим следующий результат:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}+\vec{b}=(1+2,\,-3+2)=(5,\,-1)">
</p>

Отдадим NumPy всю грязную работу и посмотрим, что получится.   

```python
vector_a = np.array([1, -3])
vector_b = np.array([4, 2])

print(sum_of_vectors = vector_a + vector_b)
```
array([ 5, -1])


<h3>Вычитание векторов</h3>

Вычитать векторы так же просто, как и складывать. Графически это выглядит так:

<p align='center'>
   <img src="https://i.ibb.co/zS2nJVq/vec-vec-subtract.jpg" title='Вычитание векторов' height=300>
</p>

На словах звучит чуть сложнее:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{b}-\vec{a}=\vec{c}\;\;\;\vec{a}=\vec{c}+\vec{b}">
</p>

При вычитании из вектора <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> из вектора <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> необходимо найти  вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, который при сложении с вектором <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> даст в сумме <img src="https://latex.codecogs.com/gif.latex?\vec{a}">.  

И наоборот, для вычитания <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> из <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> найдем вектор <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, который при сложении с <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> даст в сумме <img src="https://latex.codecogs.com/gif.latex?\vec{b}">.  

Общая формула вычитания векторов похожа по смыслу на сложение:

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}-\vec{b}=(a_{1}-b_{1},a_{2}-b_{2},a_{3}-b_{3})" >
</p>

В NumPy вычесть вектора так же просто:

```python
>>> vector_a = np.array([1, -3])
>>> vector_b = np.array([4, 2])
>>> print(diff_of_vectors_1 = vector_a + vector_b)
>>> print(diff_of_vectors_2 = vector_b + vector_a)
```
array([-3, -5])  
array([3, 5])


<h3>Умножение вектора на число</h3>

При умножении вектора на число каждый скаляр вектора умножается на это число. В результате получается вектор исходной длины.

<p align="center">
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}*{b}=\vec{c}=(a_{1}*b,\;a_{2}*b,\;a_{3}*b)" >
</p>

Рассмотрим примеры, когда вектор <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> – ненулевой и число b не равно нулю. Иначе при умножении мы будем получать нулевой вектор.

При умножении вектора на число всегда получается вектор, параллельный исходному: <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> || <img src="https://latex.codecogs.com/gif.latex?\vec{c}">.   
Если число b положительное, то  <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> ↑↑ <img src="https://latex.codecogs.com/gif.latex?\vec{c}">. Такие векторы направлены в одну сторону и называются сонаправленными.  
Если число b отрицательное, то векторы направлены в разные стороны <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> ↑↓ <img src="https://latex.codecogs.com/gif.latex?\vec{c}">, и такие векторы называются противоположно направленными.  

В NumPy умножить вектор на число можно с помощью следующих команд :

```numpy.dot()```,  
простого значка умножения

Произведение с использованием dot() можно записать в двух вариантах:
1. numpy.dot(*вектор*, *число*);  
2. *вектор*.dot(*число*)

```python
vector_a = np.array([5,4,8,10,-3])
b = 4

vector_c = vector_a.dot(b)
vector_d = vector_a * b

print(vector_c)
print(vector_d)
```

[ 20  16  32  40 -12]  
[ 20  16  32  40 -12]
 

<h3>Массивы, списки и немного кода</h3>

Вопрос: а зачем нам вообще изучать векторы для работы с данными? Ведь можно просто передавать в Python списки. Пусть машина работает с ними. Однако NumPy обрабатывает векторы (arrays) гораздо быстрее, чем Python – списки. Разберем пример.  

Создадим массив со случайными целыми числами длиной 10 млн скаляров. Чувствуете? Работаем с Big Data!

```python
vec_a = np.random.randint(100, size=10000000)
```

*Операция ```np.random.randint()``` создает массив из случайных целых чисел. Диапазон подбора чисел лежит в границах от 0 до заданного числа, в нашем случае 100. Длина массива задается параметром ```size=...```. Полная информация по этой функции и другие способы создания массивов находятся в официальной ![доке NumPy](https://numpy.org/doc/stable/reference/random/generated/numpy.random.randint.html). Добавьте в закладки и изучите.*

Переведем масив в список (list). Нам поможет функция ```tolist()```.  

```python
list_a = vec_a.tolist()
```
Проверим, что мы все сделали правильно. Выведем первые пять объектов вектора и списка.  

```python
print(vec_a[:5])
print(list_a[:5])
```
[85 56 17 20 66]  
[85, 56, 17, 20, 66]  

Все идет по плану. Умножим список на число и вектор на число. Сравним время выполнения операций. Начнем со списка.  
Мы не можем просто написать ```list_a * 4```, так как в данном случае последовательно соединим четыре раза list_a. Получим новый список длиной 40 млн скаляров.  

```python
list_c = list_a * 4

print(len(list_c))
```

40000000

Для того, чтобы корректно умножить каждый элемент списка на число, обратимся к генераторам списков, или "списку понимания" (list comprehensions).

Время выполнения функции (в данном случае в ячейке Jupyter notebook) выведно на экран с помощью команды ```%%time``` модуля IPython, ![ссылку прикладываю](https://ipython.readthedocs.io/en/stable/interactive/magics.html).
"Магические" и другие полезные функции IPython и Jupyter описаны ![в этой стате на Хабре](https://habr.com/ru/company/wunderfund/blog/316826/).
Если вы не знакомы со вложенными циклами - вам ![сюда](https://webdevblog.ru/kogda-ispolzovat-list-comprehension-v-python/) или ![сюда](https://python-scripts.com/for-in-one-line).

```python
%%time
list_c = ([list_a[i]*4 for i in range(len(list_a))])
```
Wall time: 2.21 s

Операция умножения списка длилась более двух секунд. "Как быстро!" – скажете вы и, возможно, будете правы. Посмотрим на работу numpy и векторов.  

```python
%%time
vec_c = vec_a*4

### можно написать так -
### vec_c = vec_a.dot(4)
### или так -
### vec_c = np.dot(vec_a, 4)
```  
Wall time: 35.2 ms

Операция потребовала 35 миллисекунд. Сравним это с 2210 миллисекундами, которые потребовались для работы над списком.

```python
2210 / 35.2
```  

62.78409090909091

NumPy обработал массив в 63 раза быстрее! Что вы скажете на этот раз? В машинном обучении при работе с терабайтными массивами данных экономия времени заметно ускоряет вычисления.

Переходим к самому интересному – умножению векторов друг на друга.


<h3>Скалярное произведение векторов</h3>   

Существует три варианта умножения векторов: скалярное, ![векторное](http://mathprofi.ru/vektornoe_proizvedenie_vektorov_smeshannoe_proizvedenie.html#spv) и ![смешанное](http://mathprofi.ru/vektornoe_proizvedenie_vektorov_smeshannoe_proizvedenie.html#spv). В рамках машинного обучения чаще всего вы будете пользоваться скалярным произведением. Но обязательно прочитайте про два оставшихся метода (ссылки выше).  

**Немного теории**  
Для вычисления скалярного произведения векторов необходимо отложить два свободных вектора из одной точки и рассчитать угол между ними. Получаем примерно такую картину:

<p align='center'>
   <img src='http://mathprofi.ru/d/skaljarnoe_proizvedenie_vektorov_clip_image008.jpg' title='Векторы и угол между ними'>
</p>

Из этой иллюстрации выводим определение: скалярным произведением двух векторов <img src="https://latex.codecogs.com/gif.latex?\vec{a}"> и <img src="https://latex.codecogs.com/gif.latex?\vec{b}"> называется **число**, равное произведению длин этих векторов на косинус угла между ними.
В виде формулы это выглядит так:

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\;*\;\vec{b}=|\vec{a}|*|\vec{b}|*\cos\angle(\vec{a};\vec{b})">
</p>

Почему в ответе число, а не массив? Длины векторов <img src="https://latex.codecogs.com/gif.latex?|\vec{a}|"> и <img src="https://latex.codecogs.com/gif.latex?|\vec{b}|"> – это числа. Косинус угла между векторами – тоже число. Последовательное умножение трех чисел даст новое число.   
Посмотрим на примере. Возьмем вектор <img src="https://latex.codecogs.com/gif.latex?|\vec{a}|"> длиной 5 и <img src="https://latex.codecogs.com/gif.latex?|\vec{b}|"> длиной 6. Угол между ними составляет, например, 73 градуса.
Запишем следующее выражение:

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?ans=|\vec{a}|*|\vec{b}|*\cos\angle(\vec{a};\vec{b})=5*6*\cos(73)">
</p>  

Отправим это выражение в обработку:

```python
ans = 5 * 6 * np.cos(np.radians(73))
print(ans)
```
8.771151141682104

Мы не можем просто подать градусы в формулу, привет, школьный курс математики. Для перевода градусов в радианы мы использовали функцию ```numpy.radians```. Описание ![здесь](https://numpy.org/doc/stable/reference/generated/numpy.radians.html)

**Еще немного теории**  

Если угол между двумя векторами острый, то есть от 0 до 90 градусов, то произведение векторов будет положительным благодаря положительному косинусу. Если угол между векторами тупой, от 90 до 180 градусов, то скалярное произведение векторов будет отрицательным. Опять же из-за косинуса, который теперь также отрицательный.   
*Не помните тригонометрию? Загляните ![сюда](https://egemaximum.ru/trigonometricheskiy-krug/)*  

Если векторы строго перпендикулярны друг другу, угол между ними равен 90 градусов. В этом случае косинус угла равен нулю и скалярное произведение также равно нулю. Векторы, лежащие друг к другу под прямым углом, называются **ортогональными**. В математическом виде это обозначается так:  

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{b}=0\Leftrightarrow\vec{a}\perp\vec{b}">
</p>  

При умножении вектора на себя получается следующее:

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{a}=|\vec{a}|^2">
</p>  

И наконец, разберем три закона скалярного произведения векторов.  
1. Коммутативный, или переместительный закон: <img src="https://latex.codecogs.com/gif.latex?\vec{a}\vec{b}=\vec{b}\vec{a}">;    
2. Дистрибутивный, или распределительный закон: <img src="https://latex.codecogs.com/gif.latex?(\vec{a}+\vec{b})*\vec{c}=\vec{a}\vec{c}+\vec{a}\vec{c}">;   
3. Ассоциативный, или сочетательный закон: <img src="https://latex.codecogs.com/gif.latex?(k*\vec{a})*\vec{b}=k*(\vec{a}\vec{b})"> (константу можно вынести за скобки).

**Финальная теория**  
Неужели нам придется каждый раз высчитывать углы между векторами и косинусы этих углов? Конечно нет.  
Если векторы заданы координатами, то в момент скалярного произведения координаты с одинаковыми индексами перемножаются. Все полученные произведения складываются между собой. Рассмотрим в виде формулы:  

<p align='center'>
   <img src="https://latex.codecogs.com/gif.latex?\vec{a}vec{b}=[a_{1}*b_{1}+a_{2}*b_{2}+a_{3}*b_{3}]">
</p>  

В коде скалярное произведение можно выполнить двумя путями:
```python
numpy.dot();
значок @
```

Сравним возможные пути решения:  

```python
vec_a = np.array([4, 5, -1, 3])
vec_b = np.array([-6, 2, 8, 5])

ans_1 = vec_a @ vec_b
ans_2 = np.dot(vec_a, vec_b)

print(ans_1)
print(ans_2)
```

-7  
-7

Результат одинаковый! Используйте любой приём.

<h2>Заключение</h2>  

Мы познакомились с основными свойствами векторов. Посмотрели, как можно складывать, вычитать и умножать векторы  – друг на друга и на число. Разобрали основные законы действий над векторами.  
Мы специально не затрагивали некоторые фундаментальные темы, которые требуют отдельного погружению в аналитическую геометрию и высшую математику, чтобы у вас в голове не было математического винегрета.  
В следующей статье мы посмотрим, как векторы применяются на практике в машинном обучении, и узнаем, почему Евклид не любил бы Манхеттен и как превратить слова в вектор.
